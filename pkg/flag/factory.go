package flag

import (
	"bytes"
	"crypto/sha256"
	"fmt"
)

const (
	prefix = "yctf"
)

// instance is a package level Factory.
var instance *FlagFactory

// SetFactory sets the package level Factory.
func SetFactory(f *FlagFactory) {
	instance = f
}

func Factory() *FlagFactory {
	return instance
}

// Seed returns the package instance's seed.
func Seed() string {
	return instance.Seed()
}

// NewFlag creates the package instance's Flag.
func NewFlag(in []byte) *Flag {
	return instance.NewFlag(in)
}

// Validate validates the flag was generated by the package instance's factory.
func Validate(fl *Flag) bool {
	return instance.Validate(fl)
}

type FlagFactory struct {
	seed string
}

// NewFactory returns a simple factory that helps generate flags.
func NewFactory(seed string) *FlagFactory {
	return &FlagFactory{
		seed: seed,
	}
}

// Seed returns the seed provided as input to the factory.
func (f *FlagFactory) Seed() string {
	return f.seed
}

// Validate checks a flag to see if the seed stored in the flag
// matches the seed in the factory. It also regenerates the hash based on the
// inputs stored in the flag to ensure the value matches based on the input
func (f *FlagFactory) Validate(fl *Flag) bool {
	return fl.Seed() == f.Seed() && fl.Raw() == fmt.Sprintf("%x", sha256.Sum256(fl.Data()))
}

// NewFlag returns a flag containing a the input value, the seed stored in the factory,
// and the calculated value of that flag. The calculated value of that flag is a
// sha256 sum of the input concatenated with the seed.
func (f *FlagFactory) NewFlag(in []byte) *Flag {
	data := bytes.Join([][]byte{in, []byte(f.seed)}, []byte{})
	sum := sha256.Sum256(data)
	return &Flag{
		input: in,
		value: fmt.Sprintf("%x", sum),
		seed:  f.seed,
		data:  data,
	}
}
